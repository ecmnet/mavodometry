/****************************************************************************
 *
//time *   Copyright (c) 2019 Eike Mansfeld ecm@gmx.de. All rights reserved.
// *
// * Redistribution and use in source and binary forms, with or without
// * modification, are permitted provided that the following conditions
// * are met:
// *
// * 1. Redistributions of source code must retain the above copyright
// *    notice, this list of conditions and the following disclaimer.
// * 2. Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in
// *    the documentation and/or other materials provided with the
// *    distribution.
// * 3. Neither the name of the copyright holder nor the names of its
// *    contributors may be used to endorse or promote products derived
// *    from this software without specific prior written permission.
// *
// * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
// * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
// * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
// * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// * POSSIBILITY OF SUCH DAMAGE.
// *
// ****************************************************************************/
//
//package com.comino.mavodometry.librealsense.lib;
//
//import java.nio.DoubleBuffer;
//import java.nio.IntBuffer;
//import java.util.Arrays;
//import java.util.List;
//
//import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
//import com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper;
//import com.ochafik.lang.jnaerator.runtime.Structure;
//import com.sun.jna.Library;
//import com.sun.jna.Native;
//import com.sun.jna.NativeLibrary;
//import com.sun.jna.Pointer;
//import com.sun.jna.PointerType;
//import com.sun.jna.ptr.DoubleByReference;
//import com.sun.jna.ptr.IntByReference;
//import com.sun.jna.ptr.PointerByReference;
///**
// * JNA Wrapper for library <b>test</b><br>
// * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
// * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
// * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
// */
//public interface LibRealSense1Library extends Library {
//	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("realsense1", false, LibRealSense1Library.class);
//	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(LibRealSense1Library.JNA_LIBRARY_NAME, MangledFunctionMapper.DEFAULT_OPTIONS);
//	public static final LibRealSense1Library INSTANCE = (LibRealSense1Library)Native.loadLibrary(LibRealSense1Library.JNA_LIBRARY_NAME, LibRealSense1Library.class, MangledFunctionMapper.DEFAULT_OPTIONS);
//	/** enum values */
//
//	public static interface rs_stream {
//		/**
//		 * < Native stream of depth data produced by RealSense device<br>
//		 * <i>native declaration : line 16</i>
//		 */
//		public static final int RS_STREAM_DEPTH = 0;
//		/**
//		 * < Native stream of color data captured by RealSense device<br>
//		 * <i>native declaration : line 17</i>
//		 */
//		public static final int RS_STREAM_COLOR = 1;
//		/**
//		 * < Native stream of infrared data captured by RealSense device<br>
//		 * <i>native declaration : line 18</i>
//		 */
//		public static final int RS_STREAM_INFRARED = 2;
//		/**
//		 * < Native stream of infrared data captured from a second viewpoint by RealSense device<br>
//		 * <i>native declaration : line 19</i>
//		 */
//		public static final int RS_STREAM_INFRARED2 = 3;
//		/**
//		 * < Synthetic stream containing point cloud data generated by deprojecting the depth image<br>
//		 * <i>native declaration : line 20</i>
//		 */
//		public static final int RS_STREAM_POINTS = 5;
//		/**
//		 * < Synthetic stream containing undistorted color data with no extrinsic rotation from the depth stream<br>
//		 * <i>native declaration : line 21</i>
//		 */
//		public static final int RS_STREAM_RECTIFIED_COLOR = 6;
//		/**
//		 * < Synthetic stream containing color data but sharing intrinsics of depth stream<br>
//		 * <i>native declaration : line 22</i>
//		 */
//		public static final int RS_STREAM_COLOR_ALIGNED_TO_DEPTH = 7;
//		/**
//		 * < Synthetic stream containing second viewpoint infrared data but sharing intrinsics of depth stream<br>
//		 * <i>native declaration : line 23</i>
//		 */
//		public static final int RS_STREAM_INFRARED2_ALIGNED_TO_DEPTH = 8;
//		/**
//		 * < Synthetic stream containing depth data but sharing intrinsics of color stream<br>
//		 * <i>native declaration : line 24</i>
//		 */
//		public static final int RS_STREAM_DEPTH_ALIGNED_TO_COLOR = 9;
//		/**
//		 * < Synthetic stream containing depth data but sharing intrinsics of rectified color stream<br>
//		 * <i>native declaration : line 25</i>
//		 */
//		public static final int RS_STREAM_DEPTH_ALIGNED_TO_RECTIFIED_COLOR = 10;
//		/**
//		 * < Synthetic stream containing depth data but sharing intrinsics of second viewpoint infrared stream<br>
//		 * <i>native declaration : line 26</i>
//		 */
//		public static final int RS_STREAM_DEPTH_ALIGNED_TO_INFRARED2 = 11;
//		/** <i>native declaration : line 27</i> */
//		public static final int RS_STREAM_COUNT = 12;
//		/** <i>native declaration : line 28</i> */
//		public static final int RS_STREAM_MAX_ENUM = 0x7FFFFFFF;
//	};
//	/** enum values */
//	public static interface rs_format {
//		/** <i>native declaration : line 33</i> */
//		public static final int RS_FORMAT_ANY = 0;
//		/**
//		 * < 16 bit linear depth values. The depth is meters is equal to depth scale * pixel value<br>
//		 * <i>native declaration : line 34</i>
//		 */
//		public static final int RS_FORMAT_Z16 = 1;
//		/**
//		 * < 16 bit linear disparity values. The depth in meters is equal to depth scale / pixel value<br>
//		 * <i>native declaration : line 35</i>
//		 */
//		public static final int RS_FORMAT_DISPARITY16 = 2;
//		/**
//		 * < 32 bit floating point 3D coordinates.<br>
//		 * <i>native declaration : line 36</i>
//		 */
//		public static final int RS_FORMAT_XYZ32F = 3;
//		/** <i>native declaration : line 37</i> */
//		public static final int RS_FORMAT_YUYV = 4;
//		/** <i>native declaration : line 38</i> */
//		public static final int RS_FORMAT_RGB8 = 5;
//		/** <i>native declaration : line 39</i> */
//		public static final int RS_FORMAT_BGR8 = 6;
//		/** <i>native declaration : line 40</i> */
//		public static final int RS_FORMAT_RGBA8 = 7;
//		/** <i>native declaration : line 41</i> */
//		public static final int RS_FORMAT_BGRA8 = 8;
//		/** <i>native declaration : line 42</i> */
//		public static final int RS_FORMAT_Y8 = 9;
//		/** <i>native declaration : line 43</i> */
//		public static final int RS_FORMAT_Y16 = 10;
//		/**
//		 * < Four 10-bit luminance values encoded into a 5-byte macropixel<br>
//		 * <i>native declaration : line 44</i>
//		 */
//		public static final int RS_FORMAT_RAW10 = 11;
//		/** <i>native declaration : line 45</i> */
//		public static final int RS_FORMAT_COUNT = 12;
//		/** <i>native declaration : line 46</i> */
//		public static final int RS_FORMAT_MAX_ENUM = 0x7FFFFFFF;
//	};
//	/** enum values */
//	public static interface rs_preset {
//		/** <i>native declaration : line 51</i> */
//		public static final int RS_PRESET_BEST_QUALITY = 0;
//		/** <i>native declaration : line 52</i> */
//		public static final int RS_PRESET_LARGEST_IMAGE = 1;
//		/** <i>native declaration : line 53</i> */
//		public static final int RS_PRESET_HIGHEST_FRAMERATE = 2;
//		/** <i>native declaration : line 54</i> */
//		public static final int RS_PRESET_COUNT = 3;
//		/** <i>native declaration : line 55</i> */
//		public static final int RS_PRESET_MAX_ENUM = 0x7FFFFFFF;
//	};
//	/** enum values */
//	public static interface rs_distortion {
//		/**
//		 * < Rectilinear images, no distortion compensation required<br>
//		 * <i>native declaration : line 60</i>
//		 */
//		public static final int RS_DISTORTION_NONE = 0;
//		/**
//		 * < Equivalent to Brown-Conrady distortion, except that tangential distortion is applied to radially distorted points<br>
//		 * <i>native declaration : line 61</i>
//		 */
//		public static final int RS_DISTORTION_MODIFIED_BROWN_CONRADY = 1;
//		/**
//		 * < Equivalent to Brown-Conrady distortion, except undistorts image instead of distorting it<br>
//		 * <i>native declaration : line 62</i>
//		 */
//		public static final int RS_DISTORTION_INVERSE_BROWN_CONRADY = 2;
//		/** <i>native declaration : line 63</i> */
//		public static final int RS_DISTORTION_COUNT = 3;
//		/** <i>native declaration : line 64</i> */
//		public static final int RS_DISTORTION_MAX_ENUM = 0x7FFFFFFF;
//	};
//	/** enum values */
//	public static interface rs_option {
//		/** <i>native declaration : line 69</i> */
//		public static final int RS_OPTION_COLOR_BACKLIGHT_COMPENSATION = 0;
//		/** <i>native declaration : line 70</i> */
//		public static final int RS_OPTION_COLOR_BRIGHTNESS = 1;
//		/** <i>native declaration : line 71</i> */
//		public static final int RS_OPTION_COLOR_CONTRAST = 2;
//		/**
//		 * < Controls exposure time of color camera. Setting any value will disable auto exposure.<br>
//		 * <i>native declaration : line 72</i>
//		 */
//		public static final int RS_OPTION_COLOR_EXPOSURE = 3;
//		/** <i>native declaration : line 73</i> */
//		public static final int RS_OPTION_COLOR_GAIN = 4;
//		/** <i>native declaration : line 74</i> */
//		public static final int RS_OPTION_COLOR_GAMMA = 5;
//		/** <i>native declaration : line 75</i> */
//		public static final int RS_OPTION_COLOR_HUE = 6;
//		/** <i>native declaration : line 76</i> */
//		public static final int RS_OPTION_COLOR_SATURATION = 7;
//		/** <i>native declaration : line 77</i> */
//		public static final int RS_OPTION_COLOR_SHARPNESS = 8;
//		/**
//		 * < Controls white balance of color image. Setting any value will disable auto white balance.<br>
//		 * <i>native declaration : line 78</i>
//		 */
//		public static final int RS_OPTION_COLOR_WHITE_BALANCE = 9;
//		/**
//		 * < Set to 1 to enable automatic exposure control, or 0 to return to manual control<br>
//		 * <i>native declaration : line 79</i>
//		 */
//		public static final int RS_OPTION_COLOR_ENABLE_AUTO_EXPOSURE = 10;
//		/**
//		 * < Set to 1 to enable automatic white balance control, or 0 to return to manual control<br>
//		 * <i>native declaration : line 80</i>
//		 */
//		public static final int RS_OPTION_COLOR_ENABLE_AUTO_WHITE_BALANCE = 11;
//		/**
//		 * < 0 - 15<br>
//		 * <i>native declaration : line 81</i>
//		 */
//		public static final int RS_OPTION_F200_LASER_POWER = 12;
//		/**
//		 * < 0 - 3<br>
//		 * <i>native declaration : line 82</i>
//		 */
//		public static final int RS_OPTION_F200_ACCURACY = 13;
//		/**
//		 * < 0 - 100<br>
//		 * <i>native declaration : line 83</i>
//		 */
//		public static final int RS_OPTION_F200_MOTION_RANGE = 14;
//		/**
//		 * < 0 - 7<br>
//		 * <i>native declaration : line 84</i>
//		 */
//		public static final int RS_OPTION_F200_FILTER_OPTION = 15;
//		/**
//		 * < 0 - 15<br>
//		 * <i>native declaration : line 85</i>
//		 */
//		public static final int RS_OPTION_F200_CONFIDENCE_THRESHOLD = 16;
//		/**
//		 * < {2, 5, 15, 30, 60}<br>
//		 * <i>native declaration : line 86</i>
//		 */
//		public static final int RS_OPTION_SR300_DYNAMIC_FPS = 17;
//		/** <i>native declaration : line 87</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_ENABLE_MOTION_VERSUS_RANGE = 18;
//		/** <i>native declaration : line 88</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_ENABLE_LASER = 19;
//		/** <i>native declaration : line 89</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_MIN_MOTION_VERSUS_RANGE = 20;
//		/** <i>native declaration : line 90</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_MAX_MOTION_VERSUS_RANGE = 21;
//		/** <i>native declaration : line 91</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_START_MOTION_VERSUS_RANGE = 22;
//		/** <i>native declaration : line 92</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_MIN_LASER = 23;
//		/** <i>native declaration : line 93</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_MAX_LASER = 24;
//		/** <i>native declaration : line 94</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_START_LASER = 25;
//		/** <i>native declaration : line 95</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_UPPER_THRESHOLD = 26;
//		/** <i>native declaration : line 96</i> */
//		public static final int RS_OPTION_SR300_AUTO_RANGE_LOWER_THRESHOLD = 27;
//		/**
//		 * < {0, 1}<br>
//		 * <i>native declaration : line 97</i>
//		 */
//		public static final int RS_OPTION_R200_LR_AUTO_EXPOSURE_ENABLED = 28;
//		/**
//		 * < 100 - 1600 (Units of 0.01)<br>
//		 * <i>native declaration : line 98</i>
//		 */
//		public static final int RS_OPTION_R200_LR_GAIN = 29;
//		/**
//		 * < > 0 (Units of 0.1 ms)<br>
//		 * <i>native declaration : line 99</i>
//		 */
//		public static final int RS_OPTION_R200_LR_EXPOSURE = 30;
//		/**
//		 * < {0, 1}<br>
//		 * <i>native declaration : line 100</i>
//		 */
//		public static final int RS_OPTION_R200_EMITTER_ENABLED = 31;
//		/**
//		 * < micrometers per increment in integer depth values, 1000 is default (mm scale)<br>
//		 * <i>native declaration : line 101</i>
//		 */
//		public static final int RS_OPTION_R200_DEPTH_UNITS = 32;
//		/**
//		 * < {0 - USHORT_MAX}. Can only be set before streaming starts.<br>
//		 * <i>native declaration : line 102</i>
//		 */
//		public static final int RS_OPTION_R200_DEPTH_CLAMP_MIN = 33;
//		/**
//		 * < {0 - USHORT_MAX}. Can only be set before streaming starts.<br>
//		 * <i>native declaration : line 103</i>
//		 */
//		public static final int RS_OPTION_R200_DEPTH_CLAMP_MAX = 34;
//		/**
//		 * < {0 - 1000}. The increments in integer disparity values corresponding to one pixel of disparity. Can only be set before streaming starts.<br>
//		 * <i>native declaration : line 104</i>
//		 */
//		public static final int RS_OPTION_R200_DISPARITY_MULTIPLIER = 35;
//		/**
//		 * < {0 - 512}. Can only be set before streaming starts.<br>
//		 * <i>native declaration : line 105</i>
//		 */
//		public static final int RS_OPTION_R200_DISPARITY_SHIFT = 36;
//		/** <i>native declaration : line 106</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_MEAN_INTENSITY_SET_POINT = 37;
//		/** <i>native declaration : line 107</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_BRIGHT_RATIO_SET_POINT = 38;
//		/** <i>native declaration : line 108</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_KP_GAIN = 39;
//		/** <i>native declaration : line 109</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_KP_EXPOSURE = 40;
//		/** <i>native declaration : line 110</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_KP_DARK_THRESHOLD = 41;
//		/** <i>native declaration : line 111</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_TOP_EDGE = 42;
//		/** <i>native declaration : line 112</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_BOTTOM_EDGE = 43;
//		/** <i>native declaration : line 113</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_LEFT_EDGE = 44;
//		/** <i>native declaration : line 114</i> */
//		public static final int RS_OPTION_R200_AUTO_EXPOSURE_RIGHT_EDGE = 45;
//		/** <i>native declaration : line 115</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_ESTIMATE_MEDIAN_DECREMENT = 46;
//		/** <i>native declaration : line 116</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_ESTIMATE_MEDIAN_INCREMENT = 47;
//		/** <i>native declaration : line 117</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_MEDIAN_THRESHOLD = 48;
//		/** <i>native declaration : line 118</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_SCORE_MINIMUM_THRESHOLD = 49;
//		/** <i>native declaration : line 119</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_SCORE_MAXIMUM_THRESHOLD = 50;
//		/** <i>native declaration : line 120</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_TEXTURE_COUNT_THRESHOLD = 51;
//		/** <i>native declaration : line 121</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_TEXTURE_DIFFERENCE_THRESHOLD = 52;
//		/** <i>native declaration : line 122</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_SECOND_PEAK_THRESHOLD = 53;
//		/** <i>native declaration : line 123</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_NEIGHBOR_THRESHOLD = 54;
//		/** <i>native declaration : line 124</i> */
//		public static final int RS_OPTION_R200_DEPTH_CONTROL_LR_THRESHOLD = 55;
//		/** <i>native declaration : line 125</i> */
//		public static final int RS_OPTION_COUNT = 56;
//		/** <i>native declaration : line 126</i> */
//		public static final int RS_OPTION_MAX_ENUM = 0x7FFFFFFF;
//	};
//	/** enum values */
//	public static interface rs_log_severity {
//		/**
//		 * Detailed information about ordinary operations<br>
//		 * <i>native declaration : line 413</i>
//		 */
//		public static final int RS_LOG_SEVERITY_DEBUG = 0;
//		/**
//		 * Terse information about ordinary operations<br>
//		 * <i>native declaration : line 414</i>
//		 */
//		public static final int RS_LOG_SEVERITY_INFO = 1;
//		/**
//		 * Indication of possible failure<br>
//		 * <i>native declaration : line 415</i>
//		 */
//		public static final int RS_LOG_SEVERITY_WARN = 2;
//		/**
//		 * Indication of definite failure<br>
//		 * <i>native declaration : line 416</i>
//		 */
//		public static final int RS_LOG_SEVERITY_ERROR = 3;
//		/**
//		 * Indication of unrecoverable failure<br>
//		 * <i>native declaration : line 417</i>
//		 */
//		public static final int RS_LOG_SEVERITY_FATAL = 4;
//		/**
//		 * No logging will occur<br>
//		 * <i>native declaration : line 418</i>
//		 */
//		public static final int RS_LOG_SEVERITY_NONE = 5;
//		/** <i>native declaration : line 419</i> */
//		public static final int RS_LOG_SEVERITY_MAX_ENUM = 0x7FFFFFFF;
//	};
//	public static final int RS_API_VERSION = (int)4;
//	public static class rs_intrinsics extends Structure<rs_intrinsics, rs_intrinsics.ByValue, rs_intrinsics.ByReference > {
//		/** width of the image in pixels */
//		public int width;
//		/** height of the image in pixels */
//		public int height;
//		/** horizontal coordinate of the principal point of the image, as a pixel offset from the left edge */
//		public float ppx;
//		/** vertical coordinate of the principal point of the image, as a pixel offset from the top edge */
//		public float ppy;
//		/** focal length of the image plane, as a multiple of pixel width */
//		public float fx;
//		/** focal length of the image plane, as a multiple of pixel height */
//		public float fy;
//		/**
//		 * @see rs_distortion<br>
//		 * distortion model of the image<br>
//		 * C type : rs_distortion
//		 */
//		public int model;
//		/**
//		 * distortion coefficients<br>
//		 * C type : float[5]
//		 */
//		public float[] coeffs = new float[5];
//		public rs_intrinsics() {
//			super();
//		}
//		protected List<? > getFieldOrder() {
//			return Arrays.asList("width", "height", "ppx", "ppy", "fx", "fy", "model", "coeffs");
//		}
//		/**
//		 * @param width width of the image in pixels<br>
//		 * @param height height of the image in pixels<br>
//		 * @param ppx horizontal coordinate of the principal point of the image, as a pixel offset from the left edge<br>
//		 * @param ppy vertical coordinate of the principal point of the image, as a pixel offset from the top edge<br>
//		 * @param fx focal length of the image plane, as a multiple of pixel width<br>
//		 * @param fy focal length of the image plane, as a multiple of pixel height<br>
//		 * @param model @see rs_distortion<br>
//		 * distortion model of the image<br>
//		 * C type : rs_distortion<br>
//		 * @param coeffs distortion coefficients<br>
//		 * C type : float[5]
//		 */
//		public rs_intrinsics(int width, int height, float ppx, float ppy, float fx, float fy, int model, float coeffs[]) {
//			super();
//			this.width = width;
//			this.height = height;
//			this.ppx = ppx;
//			this.ppy = ppy;
//			this.fx = fx;
//			this.fy = fy;
//			this.model = model;
//			if ((coeffs.length != this.coeffs.length))
//				throw new IllegalArgumentException("Wrong array size !");
//			this.coeffs = coeffs;
//		}
//		public rs_intrinsics(Pointer peer) {
//			super(peer);
//		}
//		protected ByReference newByReference() { return new ByReference(); }
//		protected ByValue newByValue() { return new ByValue(); }
//		protected rs_intrinsics newInstance() { return new rs_intrinsics(); }
//		public static rs_intrinsics[] newArray(int arrayLength) {
//			return Structure.newArray(rs_intrinsics.class, arrayLength);
//		}
//		public static class ByReference extends rs_intrinsics implements Structure.ByReference {
//
//		};
//		public static class ByValue extends rs_intrinsics implements Structure.ByValue {
//
//		};
//	};
//	public static class rs_extrinsics extends Structure<rs_extrinsics, rs_extrinsics.ByValue, rs_extrinsics.ByReference > {
//		/**
//		 * column-major 3x3 rotation matrix<br>
//		 * C type : float[9]
//		 */
//		public float[] rotation = new float[9];
//		/**
//		 * 3 element translation vector, in meters<br>
//		 * C type : float[3]
//		 */
//		public float[] translation = new float[3];
//		public rs_extrinsics() {
//			super();
//		}
//		protected List<? > getFieldOrder() {
//			return Arrays.asList("rotation", "translation");
//		}
//		/**
//		 * @param rotation column-major 3x3 rotation matrix<br>
//		 * C type : float[9]<br>
//		 * @param translation 3 element translation vector, in meters<br>
//		 * C type : float[3]
//		 */
//		public rs_extrinsics(float rotation[], float translation[]) {
//			super();
//			if ((rotation.length != this.rotation.length))
//				throw new IllegalArgumentException("Wrong array size !");
//			this.rotation = rotation;
//			if ((translation.length != this.translation.length))
//				throw new IllegalArgumentException("Wrong array size !");
//			this.translation = translation;
//		}
//		public rs_extrinsics(Pointer peer) {
//			super(peer);
//		}
//		protected ByReference newByReference() { return new ByReference(); }
//		protected ByValue newByValue() { return new ByValue(); }
//		protected rs_extrinsics newInstance() { return new rs_extrinsics(); }
//		public static rs_extrinsics[] newArray(int arrayLength) {
//			return Structure.newArray(rs_extrinsics.class, arrayLength);
//		}
//		public static class ByReference extends rs_extrinsics implements Structure.ByReference {
//
//		};
//		public static class ByValue extends rs_extrinsics implements Structure.ByValue {
//
//		};
//	};
//	/**
//	 * Original signature : <code>rs_context* rs_create_context(int, rs_error**)</code><br>
//	 * <i>native declaration : line 151</i>
//	 */
//	PointerByReference rs_create_context(int api_version, PointerByReference error);
//	/**
//	 * Original signature : <code>void rs_delete_context(rs_context*, rs_error**)</code><br>
//	 * <i>native declaration : line 152</i><br>
//	 * @deprecated use the safer method {@link #rs_delete_context(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_delete_context(Pointer context, PointerByReference error);
//	/**
//	 * Original signature : <code>void rs_delete_context(rs_context*, rs_error**)</code><br>
//	 * <i>native declaration : line 152</i>
//	 */
//	void rs_delete_context(PointerByReference context, PointerByReference error);
//	/**
//	 * determine number of connected devices<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the count of devices<br>
//	 * Original signature : <code>int rs_get_device_count(const rs_context*, rs_error**)</code><br>
//	 * <i>native declaration : line 159</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device_count(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_get_device_count(Pointer context, PointerByReference error);
//	/**
//	 * determine number of connected devices<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the count of devices<br>
//	 * Original signature : <code>int rs_get_device_count(const rs_context*, rs_error**)</code><br>
//	 * <i>native declaration : line 159</i>
//	 */
//	int rs_get_device_count(PointerByReference context, PointerByReference error);
//	/**
//	 * retrieve connected device by index<br>
//	 * \param[in] index   the zero based index of device to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the requested device<br>
//	 * Original signature : <code>rs_device* rs_get_device(rs_context*, int, rs_error**)</code><br>
//	 * <i>native declaration : line 167</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	PointerByReference rs_get_device(Pointer context, int index, PointerByReference error);
//	/**
//	 * retrieve connected device by index<br>
//	 * \param[in] index   the zero based index of device to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the requested device<br>
//	 * Original signature : <code>rs_device* rs_get_device(rs_context*, int, rs_error**)</code><br>
//	 * <i>native declaration : line 167</i>
//	 */
//	PointerByReference rs_get_device(PointerByReference context, int index, PointerByReference error);
//	/**
//	 * retrieve a human readable device model string<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the model string, such as "Intel RealSense F200" or "Intel RealSense R200"<br>
//	 * Original signature : <code>char* rs_get_device_name(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 174</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device_name(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	Pointer rs_get_device_name(Pointer device, PointerByReference error);
//	/**
//	 * retrieve a human readable device model string<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the model string, such as "Intel RealSense F200" or "Intel RealSense R200"<br>
//	 * Original signature : <code>char* rs_get_device_name(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 174</i>
//	 */
//	Pointer rs_get_device_name(PointerByReference device, PointerByReference error);
//	/**
//	 * retrieve the unique serial number of the device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the serial number, in a format specific to the device model<br>
//	 * Original signature : <code>char* rs_get_device_serial(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 181</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device_serial(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	Pointer rs_get_device_serial(Pointer device, PointerByReference error);
//	/**
//	 * retrieve the unique serial number of the device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the serial number, in a format specific to the device model<br>
//	 * Original signature : <code>char* rs_get_device_serial(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 181</i>
//	 */
//	Pointer rs_get_device_serial(PointerByReference device, PointerByReference error);
//	/**
//	 * retrieve the version of the firmware currently installed on the device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            firmware version string, in a format is specific to device model<br>
//	 * Original signature : <code>char* rs_get_device_firmware_version(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 188</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device_firmware_version(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	Pointer rs_get_device_firmware_version(Pointer device, PointerByReference error);
//	/**
//	 * retrieve the version of the firmware currently installed on the device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            firmware version string, in a format is specific to device model<br>
//	 * Original signature : <code>char* rs_get_device_firmware_version(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 188</i>
//	 */
//	Pointer rs_get_device_firmware_version(PointerByReference device, PointerByReference error);
//	/**
//	 * retrieve extrinsic transformation between the viewpoints of two different streams<br>
//	 * \param[in] from_stream  stream whose coordinate space we will transform from<br>
//	 * \param[in] to_stream    stream whose coordinate space we will transform to<br>
//	 * \param[out] extrin      the transformation between the two streams<br>
//	 * \param[out] error       if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_extrinsics(const rs_device*, rs_stream, rs_stream, rs_extrinsics*, rs_error**)</code><br>
//	 * <i>native declaration : line 197</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device_extrinsics(com.sun.jna.ptr.PointerByReference, int, int, test.TestLibrary.rs_extrinsics, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_get_device_extrinsics(Pointer device, int from_stream, int to_stream, LibRealSense1Library.rs_extrinsics extrin, PointerByReference error);
//	/**
//	 * retrieve extrinsic transformation between the viewpoints of two different streams<br>
//	 * \param[in] from_stream  stream whose coordinate space we will transform from<br>
//	 * \param[in] to_stream    stream whose coordinate space we will transform to<br>
//	 * \param[out] extrin      the transformation between the two streams<br>
//	 * \param[out] error       if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_extrinsics(const rs_device*, rs_stream, rs_stream, rs_extrinsics*, rs_error**)</code><br>
//	 * <i>native declaration : line 197</i>
//	 */
//	void rs_get_device_extrinsics(PointerByReference device, int from_stream, int to_stream, LibRealSense1Library.rs_extrinsics extrin, PointerByReference error);
//	/**
//	 * retrieve mapping between the units of the depth image and meters<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            depth in meters corresponding to a depth value of 1<br>
//	 * Original signature : <code>float rs_get_device_depth_scale(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 204</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device_depth_scale(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	float rs_get_device_depth_scale(Pointer device, PointerByReference error);
//	/**
//	 * retrieve mapping between the units of the depth image and meters<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            depth in meters corresponding to a depth value of 1<br>
//	 * Original signature : <code>float rs_get_device_depth_scale(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 204</i>
//	 */
//	float rs_get_device_depth_scale(PointerByReference device, PointerByReference error);
//	/**
//	 * determine if the device allows a specific option to be queried and set<br>
//	 * \param[in] option  the option to check for support<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            true if the option can be queried and set<br>
//	 * Original signature : <code>int rs_device_supports_option(const rs_device*, rs_option, rs_error**)</code><br>
//	 * <i>native declaration : line 212</i><br>
//	 * @deprecated use the safer method {@link #rs_device_supports_option(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_device_supports_option(Pointer device, int option, PointerByReference error);
//	/**
//	 * determine if the device allows a specific option to be queried and set<br>
//	 * \param[in] option  the option to check for support<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            true if the option can be queried and set<br>
//	 * Original signature : <code>int rs_device_supports_option(const rs_device*, rs_option, rs_error**)</code><br>
//	 * <i>native declaration : line 212</i>
//	 */
//	int rs_device_supports_option(PointerByReference device, int option, PointerByReference error);
//	/**
//	 * determine the number of streaming modes available for a given stream<br>
//	 * \param[in] stream  the stream whose modes will be enumerated<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the count of available modes<br>
//	 * Original signature : <code>int rs_get_stream_mode_count(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 220</i><br>
//	 * @deprecated use the safer method {@link #rs_get_stream_mode_count(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_get_stream_mode_count(Pointer device, int stream, PointerByReference error);
//	/**
//	 * determine the number of streaming modes available for a given stream<br>
//	 * \param[in] stream  the stream whose modes will be enumerated<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the count of available modes<br>
//	 * Original signature : <code>int rs_get_stream_mode_count(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 220</i>
//	 */
//	int rs_get_stream_mode_count(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * determine the properties of a specific streaming mode<br>
//	 * \param[in] stream      the stream whose mode will be queried<br>
//	 * \param[in] index       the zero based index of the streaming mode<br>
//	 * \param[out] width      the width of a frame image in pixels<br>
//	 * \param[out] height     the height of a frame image in pixels<br>
//	 * \param[out] format     the pixel format of a frame image<br>
//	 * \param[out] framerate  the number of frames which will be streamed per second<br>
//	 * \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_stream_mode(const rs_device*, rs_stream, int, int*, int*, rs_format*, int*, rs_error**)</code><br>
//	 * <i>native declaration : line 232</i><br>
//	 * @deprecated use the safer methods {@link #rs_get_stream_mode(com.sun.jna.ptr.PointerByReference, int, int, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, com.sun.jna.ptr.PointerByReference)} and {@link #rs_get_stream_mode(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_get_stream_mode(Pointer device, int stream, int index, IntByReference width, IntByReference height, IntByReference format, IntByReference framerate, PointerByReference error);
//	/**
//	 * determine the properties of a specific streaming mode<br>
//	 * \param[in] stream      the stream whose mode will be queried<br>
//	 * \param[in] index       the zero based index of the streaming mode<br>
//	 * \param[out] width      the width of a frame image in pixels<br>
//	 * \param[out] height     the height of a frame image in pixels<br>
//	 * \param[out] format     the pixel format of a frame image<br>
//	 * \param[out] framerate  the number of frames which will be streamed per second<br>
//	 * \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_stream_mode(const rs_device*, rs_stream, int, int*, int*, rs_format*, int*, rs_error**)</code><br>
//	 * <i>native declaration : line 232</i>
//	 */
//	void rs_get_stream_mode(PointerByReference device, int stream, int index, IntBuffer width, IntBuffer height, IntBuffer format, IntBuffer framerate, PointerByReference error);
//	/**
//	 * determine the properties of a specific streaming mode<br>
//	 * \param[in] stream      the stream whose mode will be queried<br>
//	 * \param[in] index       the zero based index of the streaming mode<br>
//	 * \param[out] width      the width of a frame image in pixels<br>
//	 * \param[out] height     the height of a frame image in pixels<br>
//	 * \param[out] format     the pixel format of a frame image<br>
//	 * \param[out] framerate  the number of frames which will be streamed per second<br>
//	 * \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_stream_mode(const rs_device*, rs_stream, int, int*, int*, rs_format*, int*, rs_error**)</code><br>
//	 * <i>native declaration : line 232</i>
//	 */
//	void rs_get_stream_mode(PointerByReference device, int stream, int index, IntByReference width, IntByReference height, IntByReference format, IntByReference framerate, PointerByReference error);
//	/**
//	 * enable a specific stream and request specific properties<br>
//	 * \param[in] stream     the stream to enable<br>
//	 * \param[in] width      the desired width of a frame image in pixels, or 0 if any width is acceptable<br>
//	 * \param[in] height     the desired height of a frame image in pixels, or 0 if any height is acceptable<br>
//	 * \param[in] format     the pixel format of a frame image, or ANY if any format is acceptable<br>
//	 * \param[in] framerate  the number of frames which will be streamed per second, or 0 if any framerate is acceptable<br>
//	 * \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_enable_stream(rs_device*, rs_stream, int, int, rs_format, int, rs_error**)</code><br>
//	 * <i>native declaration : line 243</i><br>
//	 * @deprecated use the safer method {@link #rs_enable_stream(com.sun.jna.ptr.PointerByReference, int, int, int, int, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_enable_stream(Pointer device, int stream, int width, int height, int format, int framerate, PointerByReference error);
//	/**
//	 * enable a specific stream and request specific properties<br>
//	 * \param[in] stream     the stream to enable<br>
//	 * \param[in] width      the desired width of a frame image in pixels, or 0 if any width is acceptable<br>
//	 * \param[in] height     the desired height of a frame image in pixels, or 0 if any height is acceptable<br>
//	 * \param[in] format     the pixel format of a frame image, or ANY if any format is acceptable<br>
//	 * \param[in] framerate  the number of frames which will be streamed per second, or 0 if any framerate is acceptable<br>
//	 * \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_enable_stream(rs_device*, rs_stream, int, int, rs_format, int, rs_error**)</code><br>
//	 * <i>native declaration : line 243</i>
//	 */
//	void rs_enable_stream(PointerByReference device, int stream, int width, int height, int format, int framerate, PointerByReference error);
//	/**
//	 * enable a specific stream and request properties using a preset<br>
//	 * \param[in] stream  the stream to enable<br>
//	 * \param[in] preset  the preset to use to enable the stream<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_enable_stream_preset(rs_device*, rs_stream, rs_preset, rs_error**)</code><br>
//	 * <i>native declaration : line 251</i><br>
//	 * @deprecated use the safer method {@link #rs_enable_stream_preset(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_enable_stream_preset(Pointer device, int stream, int preset, PointerByReference error);
//	/**
//	 * enable a specific stream and request properties using a preset<br>
//	 * \param[in] stream  the stream to enable<br>
//	 * \param[in] preset  the preset to use to enable the stream<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_enable_stream_preset(rs_device*, rs_stream, rs_preset, rs_error**)</code><br>
//	 * <i>native declaration : line 251</i>
//	 */
//	void rs_enable_stream_preset(PointerByReference device, int stream, int preset, PointerByReference error);
//	/**
//	 * disable a specific stream<br>
//	 * \param[in] stream  the stream to disable<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_disable_stream(rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 258</i><br>
//	 * @deprecated use the safer method {@link #rs_disable_stream(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_disable_stream(Pointer device, int stream, PointerByReference error);
//	/**
//	 * disable a specific stream<br>
//	 * \param[in] stream  the stream to disable<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_disable_stream(rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 258</i>
//	 */
//	void rs_disable_stream(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * determine if a specific stream is enabled<br>
//	 * \param[in] stream  the stream to check<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            true if the stream is currently enabled<br>
//	 * Original signature : <code>int rs_is_stream_enabled(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 266</i><br>
//	 * @deprecated use the safer method {@link #rs_is_stream_enabled(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_is_stream_enabled(Pointer device, int stream, PointerByReference error);
//	/**
//	 * determine if a specific stream is enabled<br>
//	 * \param[in] stream  the stream to check<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            true if the stream is currently enabled<br>
//	 * Original signature : <code>int rs_is_stream_enabled(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 266</i>
//	 */
//	int rs_is_stream_enabled(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * retrieve the width in pixels of a specific stream, equivalent to the width field from the stream's intrinsics<br>
//	 * \param[in] stream  the stream whose width to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the width in pixels of images from this stream<br>
//	 * Original signature : <code>int rs_get_stream_width(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 274</i><br>
//	 * @deprecated use the safer method {@link #rs_get_stream_width(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_get_stream_width(Pointer device, int stream, PointerByReference error);
//	/**
//	 * retrieve the width in pixels of a specific stream, equivalent to the width field from the stream's intrinsics<br>
//	 * \param[in] stream  the stream whose width to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the width in pixels of images from this stream<br>
//	 * Original signature : <code>int rs_get_stream_width(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 274</i>
//	 */
//	int rs_get_stream_width(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * retrieve the height in pixels of a specific stream, equivalent to the height field from the stream's intrinsics<br>
//	 * \param[in] stream  the stream whose height to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the height in pixels of images from this stream<br>
//	 * Original signature : <code>int rs_get_stream_height(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 282</i><br>
//	 * @deprecated use the safer method {@link #rs_get_stream_height(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_get_stream_height(Pointer device, int stream, PointerByReference error);
//	/**
//	 * retrieve the height in pixels of a specific stream, equivalent to the height field from the stream's intrinsics<br>
//	 * \param[in] stream  the stream whose height to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the height in pixels of images from this stream<br>
//	 * Original signature : <code>int rs_get_stream_height(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 282</i>
//	 */
//	int rs_get_stream_height(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * retrieve the pixel format for a specific stream<br>
//	 * \param[in] stream  the stream whose format to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the pixel format of the stream<br>
//	 * Original signature : <code>rs_format rs_get_stream_format(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 290</i><br>
//	 * @deprecated use the safer method {@link #rs_get_stream_format(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_get_stream_format(Pointer device, int stream, PointerByReference error);
//	/**
//	 * retrieve the pixel format for a specific stream<br>
//	 * \param[in] stream  the stream whose format to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the pixel format of the stream<br>
//	 * Original signature : <code>rs_format rs_get_stream_format(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 290</i>
//	 */
//	int rs_get_stream_format(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * retrieve the framerate for a specific stream<br>
//	 * \param[in] stream  the stream whose framerate to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the framerate of the stream, in frames per second<br>
//	 * Original signature : <code>int rs_get_stream_framerate(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 298</i><br>
//	 * @deprecated use the safer method {@link #rs_get_stream_framerate(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_get_stream_framerate(Pointer device, int stream, PointerByReference error);
//	/**
//	 * retrieve the framerate for a specific stream<br>
//	 * \param[in] stream  the stream whose framerate to retrieve<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the framerate of the stream, in frames per second<br>
//	 * Original signature : <code>int rs_get_stream_framerate(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 298</i>
//	 */
//	int rs_get_stream_framerate(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * retrieve intrinsic camera parameters for a specific stream<br>
//	 * \param[in] stream   the stream whose parameters to retrieve<br>
//	 * \param[out] intrin  the intrinsic parameters of the stream<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_stream_intrinsics(const rs_device*, rs_stream, rs_intrinsics*, rs_error**)</code><br>
//	 * <i>native declaration : line 306</i><br>
//	 * @deprecated use the safer method {@link #rs_get_stream_intrinsics(com.sun.jna.ptr.PointerByReference, int, test.TestLibrary.rs_intrinsics, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_get_stream_intrinsics(Pointer device, int stream, LibRealSense1Library.rs_intrinsics intrin, PointerByReference error);
//	/**
//	 * retrieve intrinsic camera parameters for a specific stream<br>
//	 * \param[in] stream   the stream whose parameters to retrieve<br>
//	 * \param[out] intrin  the intrinsic parameters of the stream<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_stream_intrinsics(const rs_device*, rs_stream, rs_intrinsics*, rs_error**)</code><br>
//	 * <i>native declaration : line 306</i>
//	 */
//	void rs_get_stream_intrinsics(PointerByReference device, int stream, LibRealSense1Library.rs_intrinsics intrin, PointerByReference error);
//	/**
//	 * begin streaming on all enabled streams for this device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_start_device(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 312</i><br>
//	 * @deprecated use the safer method {@link #rs_start_device(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_start_device(Pointer device, PointerByReference error);
//	/**
//	 * begin streaming on all enabled streams for this device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_start_device(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 312</i>
//	 */
//	void rs_start_device(PointerByReference device, PointerByReference error);
//	/**
//	 * end streaming on all streams for this device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_stop_device(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 318</i><br>
//	 * @deprecated use the safer method {@link #rs_stop_device(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_stop_device(Pointer device, PointerByReference error);
//	/**
//	 * end streaming on all streams for this device<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_stop_device(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 318</i>
//	 */
//	void rs_stop_device(PointerByReference device, PointerByReference error);
//	/**
//	 * determine if the device is currently streaming<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            true if the device is currently streaming<br>
//	 * Original signature : <code>int rs_is_device_streaming(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 325</i><br>
//	 * @deprecated use the safer method {@link #rs_is_device_streaming(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_is_device_streaming(Pointer device, PointerByReference error);
//	/**
//	 * determine if the device is currently streaming<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            true if the device is currently streaming<br>
//	 * Original signature : <code>int rs_is_device_streaming(const rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 325</i>
//	 */
//	int rs_is_device_streaming(PointerByReference device, PointerByReference error);
//	/**
//	 * retrieve the available range of values of a supported option<br>
//	 * \param[in] option  the option whose range should be queried<br>
//	 * \param[out] min    the minimum value which will be accepted for this option<br>
//	 * \param[out] max    the maximum value which will be accepted for this option<br>
//	 * \param[out] step   the granularity of options which accept discrete values, or zero if the option accepts continuous values<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_option_range(rs_device*, rs_option, double*, double*, double*, rs_error**)</code><br>
//	 * <i>native declaration : line 335</i><br>
//	 * @deprecated use the safer methods {@link #rs_get_device_option_range(com.sun.jna.ptr.PointerByReference, int, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer, com.sun.jna.ptr.PointerByReference)} and {@link #rs_get_device_option_range(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_get_device_option_range(Pointer device, int option, DoubleByReference min, DoubleByReference max, DoubleByReference step, PointerByReference error);
//	/**
//	 * retrieve the available range of values of a supported option<br>
//	 * \param[in] option  the option whose range should be queried<br>
//	 * \param[out] min    the minimum value which will be accepted for this option<br>
//	 * \param[out] max    the maximum value which will be accepted for this option<br>
//	 * \param[out] step   the granularity of options which accept discrete values, or zero if the option accepts continuous values<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_option_range(rs_device*, rs_option, double*, double*, double*, rs_error**)</code><br>
//	 * <i>native declaration : line 335</i>
//	 */
//	void rs_get_device_option_range(PointerByReference device, int option, DoubleBuffer min, DoubleBuffer max, DoubleBuffer step, PointerByReference error);
//	/**
//	 * retrieve the available range of values of a supported option<br>
//	 * \param[in] option  the option whose range should be queried<br>
//	 * \param[out] min    the minimum value which will be accepted for this option<br>
//	 * \param[out] max    the maximum value which will be accepted for this option<br>
//	 * \param[out] step   the granularity of options which accept discrete values, or zero if the option accepts continuous values<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_option_range(rs_device*, rs_option, double*, double*, double*, rs_error**)</code><br>
//	 * <i>native declaration : line 335</i>
//	 */
//	void rs_get_device_option_range(PointerByReference device, int option, DoubleByReference min, DoubleByReference max, DoubleByReference step, PointerByReference error);
//	/**
//	 * efficiently retrieve the value of an arbitrary number of options, using minimal hardware IO<br>
//	 * \param[in] options  the array of options which should be queried<br>
//	 * \param[in] count    the length of the options and values arrays<br>
//	 * \param[out] values  the array which will receive the values of the queried options<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_options(rs_device*, const rs_option*, int, double*, rs_error**)</code><br>
//	 * <i>native declaration : line 344</i><br>
//	 * @deprecated use the safer methods {@link #rs_get_device_options(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, int, java.nio.DoubleBuffer, com.sun.jna.ptr.PointerByReference)} and {@link #rs_get_device_options(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_get_device_options(Pointer device, IntByReference options, int count, DoubleByReference values, PointerByReference error);
//	/**
//	 * efficiently retrieve the value of an arbitrary number of options, using minimal hardware IO<br>
//	 * \param[in] options  the array of options which should be queried<br>
//	 * \param[in] count    the length of the options and values arrays<br>
//	 * \param[out] values  the array which will receive the values of the queried options<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_options(rs_device*, const rs_option*, int, double*, rs_error**)</code><br>
//	 * <i>native declaration : line 344</i>
//	 */
//	void rs_get_device_options(PointerByReference device, IntBuffer options, int count, DoubleBuffer values, PointerByReference error);
//	/**
//	 * efficiently retrieve the value of an arbitrary number of options, using minimal hardware IO<br>
//	 * \param[in] options  the array of options which should be queried<br>
//	 * \param[in] count    the length of the options and values arrays<br>
//	 * \param[out] values  the array which will receive the values of the queried options<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_get_device_options(rs_device*, const rs_option*, int, double*, rs_error**)</code><br>
//	 * <i>native declaration : line 344</i>
//	 */
//	void rs_get_device_options(PointerByReference device, IntByReference options, int count, DoubleByReference values, PointerByReference error);
//	/**
//	 * efficiently set the value of an arbitrary number of options, using minimal hardware IO<br>
//	 * \param[in] options  the array of options which should be set<br>
//	 * \param[in] count    the length of the options and values arrays<br>
//	 * \param[in] values   the array of values to which the options should be set<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_set_device_options(rs_device*, const rs_option*, int, const double*, rs_error**)</code><br>
//	 * <i>native declaration : line 353</i><br>
//	 * @deprecated use the safer methods {@link #rs_set_device_options(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, int, double[], com.sun.jna.ptr.PointerByReference)} and {@link #rs_set_device_options(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_set_device_options(Pointer device, IntByReference options, int count, DoubleByReference values, PointerByReference error);
//	/**
//	 * efficiently set the value of an arbitrary number of options, using minimal hardware IO<br>
//	 * \param[in] options  the array of options which should be set<br>
//	 * \param[in] count    the length of the options and values arrays<br>
//	 * \param[in] values   the array of values to which the options should be set<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_set_device_options(rs_device*, const rs_option*, int, const double*, rs_error**)</code><br>
//	 * <i>native declaration : line 353</i>
//	 */
//	void rs_set_device_options(PointerByReference device, IntBuffer options, int count, double values[], PointerByReference error);
//	/**
//	 * efficiently set the value of an arbitrary number of options, using minimal hardware IO<br>
//	 * \param[in] options  the array of options which should be set<br>
//	 * \param[in] count    the length of the options and values arrays<br>
//	 * \param[in] values   the array of values to which the options should be set<br>
//	 * \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_set_device_options(rs_device*, const rs_option*, int, const double*, rs_error**)</code><br>
//	 * <i>native declaration : line 353</i>
//	 */
//	void rs_set_device_options(PointerByReference device, IntByReference options, int count, DoubleByReference values, PointerByReference error);
//	/**
//	 * retrieve the current value of a single option<br>
//	 * \param[in] option  the option whose value should be retrieved<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the value of the option<br>
//	 * Original signature : <code>double rs_get_device_option(rs_device*, rs_option, rs_error**)</code><br>
//	 * <i>native declaration : line 361</i><br>
//	 * @deprecated use the safer method {@link #rs_get_device_option(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	double rs_get_device_option(Pointer device, int option, PointerByReference error);
//	/**
//	 * retrieve the current value of a single option<br>
//	 * \param[in] option  the option whose value should be retrieved<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the value of the option<br>
//	 * Original signature : <code>double rs_get_device_option(rs_device*, rs_option, rs_error**)</code><br>
//	 * <i>native declaration : line 361</i>
//	 */
//	double rs_get_device_option(PointerByReference device, int option, PointerByReference error);
//	/**
//	 * set the current value of a single option<br>
//	 * \param[in] option  the option whose value should be set<br>
//	 * \param[in] value   the value of the option<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_set_device_option(rs_device*, rs_option, double, rs_error**)</code><br>
//	 * <i>native declaration : line 369</i><br>
//	 * @deprecated use the safer method {@link #rs_set_device_option(com.sun.jna.ptr.PointerByReference, int, double, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_set_device_option(Pointer device, int option, double value, PointerByReference error);
//	/**
//	 * set the current value of a single option<br>
//	 * \param[in] option  the option whose value should be set<br>
//	 * \param[in] value   the value of the option<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_set_device_option(rs_device*, rs_option, double, rs_error**)</code><br>
//	 * <i>native declaration : line 369</i>
//	 */
//	void rs_set_device_option(PointerByReference device, int option, double value, PointerByReference error);
//	/**
//	 * block until new frames are available<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_wait_for_frames(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 375</i><br>
//	 * @deprecated use the safer method {@link #rs_wait_for_frames(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_wait_for_frames(Pointer device, PointerByReference error);
//	/**
//	 * block until new frames are available<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * Original signature : <code>void rs_wait_for_frames(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 375</i>
//	 */
//	void rs_wait_for_frames(PointerByReference device, PointerByReference error);
//	/**
//	 * check if new frames are available, without blocking<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            1 if new frames are available, 0 if no new frames have arrived<br>
//	 * Original signature : <code>int rs_poll_for_frames(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 382</i><br>
//	 * @deprecated use the safer method {@link #rs_poll_for_frames(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_poll_for_frames(Pointer device, PointerByReference error);
//	/**
//	 * check if new frames are available, without blocking<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            1 if new frames are available, 0 if no new frames have arrived<br>
//	 * Original signature : <code>int rs_poll_for_frames(rs_device*, rs_error**)</code><br>
//	 * <i>native declaration : line 382</i>
//	 */
//	int rs_poll_for_frames(PointerByReference device, PointerByReference error);
//	/**
//	 * retrieve the time at which the latest frame on a stream was captured<br>
//	 * \param[in] stream  the stream whose latest frame we are interested in<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the timestamp of the frame, in milliseconds since the device was started<br>
//	 * Original signature : <code>int rs_get_frame_timestamp(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 390</i><br>
//	 * @deprecated use the safer method {@link #rs_get_frame_timestamp(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	int rs_get_frame_timestamp(Pointer device, int stream, PointerByReference error);
//	/**
//	 * retrieve the time at which the latest frame on a stream was captured<br>
//	 * \param[in] stream  the stream whose latest frame we are interested in<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the timestamp of the frame, in milliseconds since the device was started<br>
//	 * Original signature : <code>int rs_get_frame_timestamp(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 390</i>
//	 */
//	double rs_get_frame_timestamp(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * retrieve the contents of the latest frame on a stream<br>
//	 * \param[in] stream  the stream whose latest frame we are interested in<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the pointer to the start of the frame data<br>
//	 * Original signature : <code>void* rs_get_frame_data(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 398</i><br>
//	 * @deprecated use the safer method {@link #rs_get_frame_data(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	Pointer rs_get_frame_data(Pointer device, int stream, PointerByReference error);
//	/**
//	 * retrieve the contents of the latest frame on a stream<br>
//	 * \param[in] stream  the stream whose latest frame we are interested in<br>
//	 * \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored<br>
//	 * \return            the pointer to the start of the frame data<br>
//	 * Original signature : <code>void* rs_get_frame_data(const rs_device*, rs_stream, rs_error**)</code><br>
//	 * <i>native declaration : line 398</i>
//	 */
//	Pointer rs_get_frame_data(PointerByReference device, int stream, PointerByReference error);
//	/**
//	 * Original signature : <code>char* rs_get_failed_function(const rs_error*)</code><br>
//	 * <i>native declaration : line 400</i><br>
//	 * @deprecated use the safer method {@link #rs_get_failed_function(com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	Pointer rs_get_failed_function(Pointer error);
//	/**
//	 * Original signature : <code>char* rs_get_failed_function(const rs_error*)</code><br>
//	 * <i>native declaration : line 400</i>
//	 */
//	Pointer rs_get_failed_function(PointerByReference error);
//	/**
//	 * Original signature : <code>char* rs_get_failed_args(const rs_error*)</code><br>
//	 * <i>native declaration : line 401</i><br>
//	 * @deprecated use the safer method {@link #rs_get_failed_args(com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	Pointer rs_get_failed_args(Pointer error);
//	/**
//	 * Original signature : <code>char* rs_get_failed_args(const rs_error*)</code><br>
//	 * <i>native declaration : line 401</i>
//	 */
//	Pointer rs_get_failed_args(PointerByReference error);
//	/**
//	 * Original signature : <code>char* rs_get_error_message(const rs_error*)</code><br>
//	 * <i>native declaration : line 402</i><br>
//	 * @deprecated use the safer method {@link #rs_get_error_message(com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	Pointer rs_get_error_message(Pointer error);
//	/**
//	 * Original signature : <code>char* rs_get_error_message(const rs_error*)</code><br>
//	 * <i>native declaration : line 402</i>
//	 */
//	Pointer rs_get_error_message(PointerByReference error);
//	/**
//	 * Original signature : <code>void rs_free_error(rs_error*)</code><br>
//	 * <i>native declaration : line 403</i><br>
//	 * @deprecated use the safer method {@link #rs_free_error(com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_free_error(Pointer error);
//	/**
//	 * Original signature : <code>void rs_free_error(rs_error*)</code><br>
//	 * <i>native declaration : line 403</i>
//	 */
//	void rs_free_error(PointerByReference error);
//	/**
//	 * Original signature : <code>char* rs_stream_to_string(rs_stream)</code><br>
//	 * <i>native declaration : line 405</i>
//	 */
//	Pointer rs_stream_to_string(int stream);
//	/**
//	 * Original signature : <code>char* rs_format_to_string(rs_format)</code><br>
//	 * <i>native declaration : line 406</i>
//	 */
//	Pointer rs_format_to_string(int format);
//	/**
//	 * Original signature : <code>char* rs_preset_to_string(rs_preset)</code><br>
//	 * <i>native declaration : line 407</i>
//	 */
//	Pointer rs_preset_to_string(int preset);
//	/**
//	 * Original signature : <code>char* rs_distortion_to_string(rs_distortion)</code><br>
//	 * <i>native declaration : line 408</i>
//	 */
//	Pointer rs_distortion_to_string(int distortion);
//	/**
//	 * Original signature : <code>char* rs_option_to_string(rs_option)</code><br>
//	 * <i>native declaration : line 409</i>
//	 */
//	Pointer rs_option_to_string(int option);
//	/**
//	 * Original signature : <code>void rs_log_to_console(rs_log_severity, rs_error**)</code><br>
//	 * <i>native declaration : line 421</i>
//	 */
//	void rs_log_to_console(int min_severity, PointerByReference error);
//	/**
//	 * Original signature : <code>void rs_log_to_file(rs_log_severity, const char*, rs_error**)</code><br>
//	 * <i>native declaration : line 422</i><br>
//	 * @deprecated use the safer methods {@link #rs_log_to_file(int, java.lang.String, com.sun.jna.ptr.PointerByReference)} and {@link #rs_log_to_file(int, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference)} instead
//	 */
//	@Deprecated
//	void rs_log_to_file(int min_severity, Pointer file_path, PointerByReference error);
//	/**
//	 * Original signature : <code>void rs_log_to_file(rs_log_severity, const char*, rs_error**)</code><br>
//	 * <i>native declaration : line 422</i>
//	 */
//	void rs_log_to_file(int min_severity, String file_path, PointerByReference error);
//	public static class rs_context extends PointerType {
//		public rs_context(Pointer address) {
//			super(address);
//		}
//		public rs_context() {
//			super();
//		}
//	};
//	public static class rs_error extends PointerType {
//		public rs_error(Pointer address) {
//			super(address);
//		}
//		public rs_error() {
//			super();
//		}
//	};
//	public static class rs_device extends PointerType {
//		public rs_device(Pointer address) {
//			super(address);
//		}
//		public rs_device() {
//			super();
//		}
//	};
//}
